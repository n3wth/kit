{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "shape",
  "title": "Shape",
  "description": "Decorative SVG shape with pattern fills and responsive sizing.",
  "registryDependencies": [
    "cn"
  ],
  "files": [
    {
      "path": "registry/new-york/shape/shape.tsx",
      "content": "import { cn } from '@/lib/utils'\nimport { generatePattern, PatternType } from './patterns'\n\nexport type ShapeType =\n  | 'circle'\n  | 'square'\n  | 'triangle'\n  | 'diamond'\n  | 'hexagon'\n  | 'semicircle'\n  | 'arc'\n  | 'pill'\n  | 'star'\n\nexport type ResponsiveSize = {\n  base?: number | { width: number; height: number }\n  sm?: number | { width: number; height: number }\n  md?: number | { width: number; height: number }\n  lg?: number | { width: number; height: number }\n}\n\nexport interface ShapeProps {\n  type: ShapeType\n  /**\n   * Size of the shape. Can be:\n   * - A number (same width/height)\n   * - An object { width, height }\n   * - A responsive object { base, sm, md, lg }\n   */\n  size?: number | { width: number; height: number } | ResponsiveSize\n  color?: string\n  pattern?: PatternType\n  patternColors?: string[]\n  patternScale?: number\n  patternAngle?: number\n  rotation?: number\n  opacity?: number\n  className?: string\n  style?: React.CSSProperties\n  /** Disable animations when user prefers reduced motion (handled via CSS) */\n  'aria-hidden'?: boolean\n}\n\nfunction getShapePath(type: ShapeType): string {\n  switch (type) {\n    case 'circle':\n      return ''\n    case 'square':\n      return ''\n    case 'triangle':\n      return 'M12 2L22 20H2L12 2Z'\n    case 'diamond':\n      return 'M12 1L23 12L12 23L1 12L12 1Z'\n    case 'hexagon':\n      return 'M12 2L21.5 7V17L12 22L2.5 17V7L12 2Z'\n    case 'semicircle':\n      return 'M2 12A10 10 0 0 1 22 12Z'\n    case 'arc':\n      return 'M4 20A12 12 0 0 1 20 20'\n    case 'pill':\n      return ''\n    case 'star':\n      return 'M12 2L14.5 8.5L21.5 9L16.5 13.5L18 21L12 17L6 21L7.5 13.5L2.5 9L9.5 8.5L12 2Z'\n    default:\n      return ''\n  }\n}\n\n// Check if size is a responsive object\nfunction isResponsiveSize(size: ShapeProps['size']): size is ResponsiveSize {\n  return (\n    typeof size === 'object' &&\n    size !== null &&\n    ('base' in size || 'sm' in size || 'md' in size || 'lg' in size)\n  )\n}\n\nexport function Shape({\n  type,\n  size = 48,\n  color = 'currentColor',\n  pattern = 'solid',\n  patternColors,\n  patternScale = 1,\n  patternAngle = 45,\n  rotation = 0,\n  opacity = 1,\n  className,\n  style,\n  'aria-hidden': ariaHidden = true,\n}: ShapeProps) {\n  // Handle responsive sizes by computing base size\n  // CSS custom properties will handle the responsive scaling\n  let computedSize: number | { width: number; height: number }\n\n  if (isResponsiveSize(size)) {\n    // Use base size or fallback to first defined breakpoint\n    computedSize = size.base ?? size.sm ?? size.md ?? size.lg ?? 48\n  } else {\n    computedSize = size\n  }\n\n  const width = typeof computedSize === 'number' ? computedSize : computedSize.width\n  const height = typeof computedSize === 'number' ? computedSize : computedSize.height\n\n  // Generate responsive CSS custom properties\n  const responsiveStyles: Record<string, string> = {}\n  if (isResponsiveSize(size)) {\n    const getSize = (s: number | { width: number; height: number } | undefined) => {\n      if (!s) return undefined\n      return typeof s === 'number' ? s : s.width\n    }\n\n    if (size.base) responsiveStyles['--shape-size-base'] = `${getSize(size.base)}px`\n    if (size.sm) responsiveStyles['--shape-size-sm'] = `${getSize(size.sm)}px`\n    if (size.md) responsiveStyles['--shape-size-md'] = `${getSize(size.md)}px`\n    if (size.lg) responsiveStyles['--shape-size-lg'] = `${getSize(size.lg)}px`\n  }\n\n  const patternResult =\n    pattern !== 'solid' && patternColors\n      ? generatePattern({\n          type: pattern,\n          colors: patternColors,\n          scale: patternScale,\n          angle: patternAngle,\n        })\n      : null\n\n  const fill = patternResult?.fill ?? color\n\n  const renderShape = () => {\n    switch (type) {\n      case 'circle':\n        return <circle cx=\"12\" cy=\"12\" r=\"10\" fill={fill} />\n      case 'square':\n        return <rect x=\"2\" y=\"2\" width=\"20\" height=\"20\" rx=\"2\" fill={fill} />\n      case 'pill':\n        return <rect x=\"2\" y=\"6\" width=\"20\" height=\"12\" rx=\"6\" fill={fill} />\n      case 'arc':\n        return (\n          <path\n            d=\"M4 20A12 12 0 0 1 20 20\"\n            fill=\"none\"\n            stroke={fill}\n            strokeWidth=\"4\"\n            strokeLinecap=\"round\"\n          />\n        )\n      default: {\n        const path = getShapePath(type)\n        return path ? <path d={path} fill={fill} /> : null\n      }\n    }\n  }\n\n  // Determine if we need responsive class\n  const responsiveClass = isResponsiveSize(size) ? 'shape-responsive' : ''\n\n  return (\n    <svg\n      viewBox=\"0 0 24 24\"\n      width={width}\n      height={height}\n      className={cn('shape', responsiveClass, className)}\n      style={{\n        transform: rotation ? `rotate(${rotation}deg)` : undefined,\n        opacity,\n        ...responsiveStyles,\n        ...style,\n      }}\n      aria-hidden={ariaHidden}\n      focusable=\"false\"\n    >\n      {patternResult && (\n        <defs dangerouslySetInnerHTML={{ __html: patternResult.defs }} />\n      )}\n      {renderShape()}\n    </svg>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york/shape/patterns.ts",
      "content": "/**\n * SVG pattern generators for shapes\n * Returns pattern definition and pattern ID for use in fills\n */\n\nexport type PatternType = 'solid' | 'checkered' | 'striped' | 'dotted'\n\nexport interface PatternConfig {\n  type: PatternType\n  colors: string[]\n  scale?: number\n  angle?: number\n}\n\nlet patternCounter = 0\n\nexport function generatePatternId(): string {\n  return `pattern-${++patternCounter}-${Date.now()}`\n}\n\nexport function generateCheckeredPattern(\n  id: string,\n  colors: [string, string],\n  scale: number = 1\n): string {\n  const size = 10 * scale\n  const half = size / 2\n  return `\n    <pattern id=\"${id}\" patternUnits=\"userSpaceOnUse\" width=\"${size}\" height=\"${size}\">\n      <rect width=\"${half}\" height=\"${half}\" fill=\"${colors[0]}\"/>\n      <rect x=\"${half}\" y=\"${half}\" width=\"${half}\" height=\"${half}\" fill=\"${colors[0]}\"/>\n      <rect x=\"${half}\" width=\"${half}\" height=\"${half}\" fill=\"${colors[1]}\"/>\n      <rect y=\"${half}\" width=\"${half}\" height=\"${half}\" fill=\"${colors[1]}\"/>\n    </pattern>\n  `\n}\n\nexport function generateStripedPattern(\n  id: string,\n  colors: string[],\n  scale: number = 1,\n  angle: number = 45\n): string {\n  const stripeWidth = 4 * scale\n  const totalWidth = stripeWidth * colors.length\n  const stripes = colors\n    .map(\n      (color, i) =>\n        `<rect x=\"${i * stripeWidth}\" width=\"${stripeWidth}\" height=\"${totalWidth}\" fill=\"${color}\"/>`\n    )\n    .join('')\n  return `\n    <pattern id=\"${id}\" patternUnits=\"userSpaceOnUse\" width=\"${totalWidth}\" height=\"${totalWidth}\" patternTransform=\"rotate(${angle})\">\n      ${stripes}\n    </pattern>\n  `\n}\n\nexport function generateDottedPattern(\n  id: string,\n  bgColor: string,\n  dotColor: string,\n  scale: number = 1\n): string {\n  const size = 8 * scale\n  const radius = 1.5 * scale\n  return `\n    <pattern id=\"${id}\" patternUnits=\"userSpaceOnUse\" width=\"${size}\" height=\"${size}\">\n      <rect width=\"${size}\" height=\"${size}\" fill=\"${bgColor}\"/>\n      <circle cx=\"${size / 2}\" cy=\"${size / 2}\" r=\"${radius}\" fill=\"${dotColor}\"/>\n    </pattern>\n  `\n}\n\nexport function generatePattern(config: PatternConfig): { defs: string; fill: string } | null {\n  if (config.type === 'solid' || config.colors.length === 0) {\n    return null\n  }\n\n  const id = generatePatternId()\n  const scale = config.scale ?? 1\n\n  switch (config.type) {\n    case 'checkered':\n      return {\n        defs: generateCheckeredPattern(id, [config.colors[0], config.colors[1] || config.colors[0]], scale),\n        fill: `url(#${id})`,\n      }\n    case 'striped':\n      return {\n        defs: generateStripedPattern(id, config.colors, scale, config.angle ?? 45),\n        fill: `url(#${id})`,\n      }\n    case 'dotted':\n      return {\n        defs: generateDottedPattern(id, config.colors[0], config.colors[1] || '#fff', scale),\n        fill: `url(#${id})`,\n      }\n    default:\n      return null\n  }\n}\n",
      "type": "registry:ui"
    }
  ],
  "type": "registry:ui"
}